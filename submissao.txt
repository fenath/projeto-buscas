## main.py
## Este código está repartido entre main.py (lógicas de busca) 
## e mapa.py (grafos e funcoes de busca de cidade)
## o projeto pode ser aberto no github
## site: https://github.com/fenath/projeto-buscas

from __future__ import annotations
from typing import Callable, override
from mapa import BELEZAS, MAPA, FRONTEIRAS, CUSTOS, get_uf_by_cidade, get_cidade_by_uf, get_distancia_aerea

DESTINO_NAO_ENCONTRADO: tuple[list[Node], int] = ([], 0)

class Node():
    def __init__(self, _name: str):
        self.name: str = _name
        self.connections: list[tuple[Node, int]] = []

    def add_connection(self, conn_name: str, cost: int) -> Node:
        conn = self.get_connection_by_name(conn_name)
        if conn:
            # Conexão ja existe
            return conn
            
        conn = Node(conn_name)
        
        self.add_connection_node(conn, cost)
        conn.add_connection_node(self, cost)
        return conn
        
    def add_connection_node(self, conn_node: Node, cost: int) -> None:
        if conn_node in self.get_children():
            return
        self.connections.append((conn_node, cost))
        
    def get_connection_by_name(self, conn_name: str)\
             -> Node | None:
        result = filter(lambda n: n[0].name == conn_name, self.connections)
        result = next(result, None)
        if result:
            return result[0]
        return None
    
    def get_children(self) -> list[Node]:
        return [conn[0] for conn in self.connections]
        
    def get_costs(self) -> list[int]:
        return [conn[1] for conn in self.connections]

    def get_cost(self, conn: Node) -> int | None:
        result = filter(lambda n: n[0] == conn, self.connections)
        result = next(result, None)
        if result:
            return result[1]
        return None

    def get_connection_cost(self, conn_name: str) -> int | None:
        result = filter(lambda n: n[0].name == conn_name, self.connections)
        result = next(result, None)
        if result:
            return result[1]
        return None

    @override
    def __repr__(self) -> str:
        return f'Node({self.name})'

    @override
    def __str__(self) -> str:
        return f'Node({self.name})'

def get_capital(uf: str) -> str:
    linha = list(filter(lambda n: n[2] == uf, (l for l in MAPA)))[0]
    if not linha:
        raise ValueError(f'UF {uf} não encontrada')
    return str(linha[0])

def get_fronteiras(uf: str) -> list[str]:
    if FRONTEIRAS.get(uf) is None:
        raise ValueError(f'UF {uf} não encontrada')
    return FRONTEIRAS.get(uf, [])

def get_capitais_fronteiras(capital: str) -> list[str]:
    linha = list(filter(lambda n: n[0] == capital, (l for l in MAPA)))
    uf: str = linha[0][2]
    fronteiras_uf = get_fronteiras(uf)
    capitais: list[str] = []
    for f in fronteiras_uf:
        capitais.append(get_capital(f))
    return capitais

def g_func(rota: list[Node]) -> int:
    custo = 0
    for i in range(len(rota) - 1):
        c = rota[i].get_cost(rota[i + 1])
        if c:
            custo += c
    return custo

def get_beleza(capital: Node) -> int:
    linha = list(filter(lambda n: n[0] == capital.name, (l for l in MAPA)))
    uf: str = linha[0][2] 
    beleza = BELEZAS[uf]
    return beleza

def h_func_beleza(trajeto: list[Node], destino: Node) -> int:
    """Heurística: penaliza caminhos que passam por cidades menos belas"""
    if not trajeto:
        return 0
    ultima = trajeto[-1]
    return 10 - get_beleza(ultima)  # Quanto mais bela, menor a heurística

def h_func_distancia_aerea(trajeto: list[Node], destino: Node) -> int:
    if not trajeto: 
        return 0

    ultima = trajeto[-1]

    uf_destino = str(get_uf_by_cidade(destino.name))
    uf_ultima = str(get_uf_by_cidade(ultima.name))

    cust = int(get_distancia_aerea(uf_ultima, uf_destino))
    return cust


def a_star(_mapa: list[Node], source: Node, dest: Node, h_func: Callable[[list[Node], Node], int] = h_func_beleza) -> tuple[list[Node], int]:
    """
    Busca usando método A*
    retorna o trajeto (se houver) e o custo para o trajeto

    - source: nó de origem
    - dest: nó de destino
    - mapa: lista de nós 
        (dá para perceber que acabamos não usando o mapa porque os próprios 
        nodes já possuem conexões)
    """

    # armazenar os próximos a fazer consulta
    next_children: list[tuple[Node, list[Node]]] = []
    visitados: set[Node] = set() # Usando set pois não armazena duplicados

    # Populando primeiro
    next_children.append((source, []))

    while next_children:
        def soma_g_h_func(key: tuple[Node, list[Node]]) -> int:
            # g(n) + h(n)
            _atual, trajeto = key
            return g_func(trajeto) + h_func(trajeto + [_atual], dest)

        # Ordena pela soma do custo atual e heurística
        next_children.sort(key=soma_g_h_func)
        proximos_5 = next_children[:5]
        #print('Proximos:')
        #print('\n'.join([f'{soma_g_h_func(n):3} - {n[0].name}' for n in proximos_5]))

        # Pega o nó com menor custo total estimado
        child, trajeto = next_children.pop(0)

        if child in visitados:
            continue

        visitados.add(child)
        rota_atual = trajeto + [child]
        if child == dest:
            # chegou no destino
            return rota_atual, g_func(rota_atual)

        children = child.get_children()
        # Adiciona filhos ao fim da lista
        next_children += [(conn, rota_atual) for conn in children]

    # Se não achou o destino
    return DESTINO_NAO_ENCONTRADO

def largura(_mapa: list[Node], source: Node, dest: Node) -> tuple[list[Node], int]:
    """
    Busca em largura 
    retorna o trajeto (se houver) e o custo para o trajeto

    - source: nó de origem
    - dest: nó de destino
    - mapa: lista de nós 
        (dá para perceber que acabamos não usando o mapa porque os próprios 
        nodes já possuem conexões)
    """
    # print(f'Algoritmo de largura de {source.name} para {dest.name}')
    # Proximos filhos precisam armazenar a rota traçada
    next_children: list[tuple[Node, list[Node]]] = []
    visitados: list[Node] = []
    custo = 1

    # Popular o primeiro
    next_children.append((source, []))
    
    while next_children:
        child, trajeto = next_children.pop(0)
        # Nao voltar por um caminho ja feito
        if child in visitados:
            continue

        # print('TESTE: CITY: {} TRAJETO: {}'.format(
        #     child.name.ljust(15),
        #     '->'.join([t.name for t in trajeto]).ljust(100)
        # ))

        visitados.append(child)
        rota_atual = trajeto + [child]

        if child == dest:
            # chegou no destino
            custo = g_func(rota_atual)
            # print(f'Completou viagem de {source.name} a {dest.name}')
            # print(f'Trajeto: {[n.name for n in rota_atual]}')
            # print(f'Custo: {custo}')
            return rota_atual, custo
        
        children = child.get_children()
        # Adiciona filhos ao fim da lista
        # print('Adicionando {} filhos ({})'.format(
        #       len(children),
        #       str([s.name for s in children])
        #       ))
        next_children += [
            (conn, rota_atual) for conn in children
        ]
    
    return DESTINO_NAO_ENCONTRADO
        
    
def profundidade(_mapa: list[Node], source: Node, dest: Node) -> tuple[list[Node], int]:
    """
    Busca em profundidade
    retorna o trajeto (se houver) e o custo para o trajeto

    - source: nó de origem
    - dest: nó de destino
    - mapa: lista de nós 
    """
    print(f'Algoritmo de profundidade de {source.name} para {dest.name}')
    next_children: list[tuple[Node, list[Node]]] = []
    visitados: list[Node] = []

    next_children.append((source, []))

    while next_children:
        # Pega o último nó adicionado
        atual, trajeto = next_children.pop()

        if atual in visitados:
            continue

        visitados.append(atual)
        rota_atual = trajeto + [atual]

        if atual == dest:
            custo = g_func(rota_atual)
            return rota_atual, custo

        children = atual.get_children()

        # Como é pilha, adicionamos no final (últimos filhos serão explorados primeiro)
        next_children += [(filho, rota_atual) for filho in children if filho not in visitados]

    print('Destino não encontrado.')
    return DESTINO_NAO_ENCONTRADO


def get_cidade(mapa: list[Node], name: str) -> Node | None:
    linha = list(filter(lambda n: n.name == name, mapa))
    if not linha:
        return
    return linha[0]


def create_mapa() -> list[Node]:
    mapa: list[Node] = []

    def conectar_cidades(cidade1: Node, cidade2: Node, custo: int = 0) -> None:
        cidade1.add_connection_node(cidade2, custo)
        # Como cidades serao unidirecionais
        # cidade2.add_connection_node(cidade1)

    for linha in MAPA:
        cidade = Node(linha[0])
        mapa.append(cidade)

    def get_custos(uf: str) -> list[int]:
        return CUSTOS.get(uf, [])

    for cidade in mapa:
        uf = next(filter(lambda linha: linha[0] == cidade.name, MAPA))[2]
        capital = get_capital(uf)
        fronteiras = get_capitais_fronteiras(capital)
        custos = get_custos(uf)
        
        for front, custo in zip(fronteiras, custos):
            f_node = get_cidade(mapa, front)
            if f_node:
                conectar_cidades(cidade, f_node, custo)

    return mapa

def select_in(msg: str, opcoes: list[str]) -> int:
    i = 0
    print(msg)
    while i < len(opcoes):
        op1 = opcoes[i]

        op2 = ''
        if i+1 < len(opcoes):
            op2 = opcoes[i + 1]

        print('{:2} - {} {:2} - {}'.format(i+1, op1.ljust(15), i+2, op2.ljust(15)))
        i += 2
    o = int(input('Insira opção: '))
    if o < 0:
        return 0
    if o > len(opcoes):
        return len(opcoes) - 1
    return o - 1

def print_trajeto(trajeto: list[Node], custo: int = 0) -> None:
    if trajeto:
        print(f'Viagem de {trajeto[0].name} a {trajeto[-1].name}')
    cidades_uf = [f'{n.name}({get_uf_by_cidade(n.name)})' for n in trajeto]
    print('Trajeto: {}'.format('->'.join(cidades_uf)))
    print('Custo: {}'.format(custo))
    return None

mapa = create_mapa()
capitais = [l[0] for l in MAPA]

def main() -> None:
    i = select_in('Origem', capitais)
    source = get_cidade(mapa, capitais[i])
    if not source:
        raise ValueError('Origem mal informada')

    i = select_in('Destino', capitais)
    dest = get_cidade(mapa, capitais[i])
    if not dest:
        raise ValueError('Destino mal informado')
    
    
    print('\n-----------------')
    print('Largura')
    print('-----------------')
    trajeto, custo = largura(mapa, source, dest)
    print_trajeto(trajeto, custo)
    print('-----------------')
    
    print('\n-----------------')
    print('Profundidade')
    trajeto, custo = profundidade(mapa, source, dest)
    print_trajeto(trajeto, custo)
    print('-----------------')
    
    print('\n-----------------')
    print('A Star')
    trajeto, custo = a_star(mapa, source, dest)
    print_trajeto(trajeto, custo)
    print('-----------------')

    print('\n-----------------')
    print('A Star (distancia aerea)')
    trajeto, custo = a_star(mapa, source, dest, h_func_distancia_aerea)
    print_trajeto(trajeto, custo)
    print('-----------------')

if __name__ == '__main__':
    main()

## mapa.py

MAPA = [
    # ['Cidade'       , 'Estado'              , 'Sigla' , 'Região'       ] ,
    ['Rio Branco'     , 'Acre'                , 'AC' , 'Norte'        ] ,
    ['Maceió'         , 'Alagoas'             , 'AL' , 'Nordeste'     ] ,
    ['Macapá'         , 'Amapá'               , 'AP' , 'Norte'        ] ,
    ['Manaus'         , 'Amazonas'            , 'AM' , 'Norte'        ] ,
    ['Salvador'       , 'Bahia'               , 'BA' , 'Nordeste'     ] ,
    ['Fortaleza'      , 'Ceará'               , 'CE' , 'Nordeste'     ] ,
    ['Brasília*'      , 'Distrito Federal'    , 'DF' , 'Centro-Oeste' ] ,
    ['Vitória'        , 'Espírito Santo'      , 'ES' , 'Sudeste'      ] ,
    ['Goiânia'        , 'Goiás'               , 'GO' , 'Centro-Oeste' ] ,
    ['São Luís'       , 'Maranhão'            , 'MA' , 'Nordeste'     ] ,
    ['Cuiabá'         , 'Mato Grosso'         , 'MT' , 'Centro-Oeste' ] ,
    ['Campo Grande'   , 'Mato Grosso do Sul'  , 'MS' , 'Centro-Oeste' ] ,
    ['Belo Horizonte' , 'Minas Gerais'        , 'MG' , 'Sudeste'      ] ,
    ['Belém'          , 'Pará'                , 'PA' , 'Norte'        ] ,
    ['João Pessoa'    , 'Paraíba'             , 'PB' , 'Nordeste'     ] ,
    ['Curitiba'       , 'Paraná'              , 'PR' , 'Sul'          ] ,
    ['Recife'         , 'Pernambuco'          , 'PE' , 'Nordeste'     ] ,
    ['Teresina'       , 'Piauí'               , 'PI' , 'Nordeste'     ] ,
    ['Rio de Janeiro' , 'Rio de Janeiro'      , 'RJ' , 'Sudeste'      ] ,
    ['Natal'          , 'Rio Grande do Norte' , 'RN' , 'Nordeste'     ] ,
    ['Porto Alegre'   , 'Rio Grande do Sul'   , 'RS' , 'Sul'          ] ,
    ['Porto Velho'    , 'Rondônia'            , 'RO' , 'Norte'        ] ,
    ['Boa Vista'      , 'Roraima'             , 'RR' , 'Norte'        ] ,
    ['Florianópolis'  , 'Santa Catarina'      , 'SC' , 'Sul'          ] ,
    ['São Paulo'      , 'São Paulo'           , 'SP' , 'Sudeste'      ] ,
    ['Aracaju'        , 'Sergipe'             , 'SE' , 'Nordeste'     ] ,
    ['Palmas'         , 'Tocantins'           , 'TO' , 'Norte'        ] ,
]

FRONTEIRAS = {
    'AC': ['AM', 'RO'],
    'AL': ['BA', 'PE', 'SE'],
    'AM': ['AC', 'PA', 'RO', 'RR', 'MT'],
    'AP': ['PA'],
    'BA': ['AL', 'GO', 'MG', 'ES', 'PE', 'PI', 'TO', 'SE'],
    'CE': ['RN', 'PI', 'PB', 'PE'],
    'DF': ['GO', 'MG'],
    'ES': ['BA', 'MG', 'RJ'],
    'GO': ['BA', 'DF', 'MG', 'MS', 'MT', 'TO'],
    'MA': ['PI', 'PA', 'TO'],
    'MG': ['DF', 'BA', 'GO', 'ES', 'RJ', 'SP', 'MS'],
    'MS': ['GO', 'MT', 'PR', 'SP', 'MG'],
    'MT': ['AM', 'PA', 'TO', 'GO', 'MS', 'RO'],
    'PA': ['AP', 'MA', 'TO', 'AM', 'RO', 'MT'],
    'PB': ['PE', 'RN', 'CE'],
    'PE': ['PB', 'CE', 'AL', 'BA', 'PI'],
    'PI': ['MA', 'CE', 'PE', 'BA', 'TO'],
    'PR': ['SC', 'SP', 'MS'],
    'RJ': ['ES', 'MG', 'SP'],
    'RN': ['PB', 'CE'],
    'RO': ['AM', 'AC', 'MT', 'PA'],
    'RR': ['AM'],
    'RS': ['SC'],
    'SC': ['PR', 'RS'],
    'SE': ['AL', 'BA'],
    'SP': ['MG', 'RJ', 'PR', 'MS'],
    'TO': ['MA', 'PI', 'BA', 'GO', 'MT', 'PA']
}

BELEZAS = {
    'AC': 3,  
    'AL': 6,  
    'AM': 6,  
    'AP': 3,  
    'BA': 8,  
    'CE': 7,  
    'DF': 8,  
    'ES': 7,  
    'GO': 5,  
    'MA': 5,  
    'MG': 7,  
    'MS': 4,  
    'MT': 4,  
    'PA': 5,  
    'PB': 6,  
    'PE': 8,  
    'PI': 4,  
    'PR': 9,  
    'RJ': 10, 
    'RN': 6,  
    'RO': 3,  
    'RR': 3,  
    'RS': 8,  
    'SC': 9,  
    'SE': 5,  
    'SP': 8,  
    'TO': 4,  
}

CUSTOS = { # TODO: Adicionar custos
    'AC': [1445, 544],                     
    'AL': [632, 285, 294],
    'AM': [1445, 5298, 901, 785, 2357],
    'AP': [528],
    'BA': [632, 1643, 1372, 1202, 839, 1163, 1454, 356],
    'CE': [537, 634, 688, 800],
    'DF': [209, 716],
    'ES': [1202, 524, 528],
    'GO': [1643, 209, 906, 935, 934, 874],
    'MA': [446, 806, 1386],
    'MG': [716, 1372, 906, 524, 434, 586, 528],
    'MS': [935, 694, 991, 1014, 528],
    'MT': [2357, 2941, 1784, 934, 694, 1456],
    'PA': [528, 806, 1283, 5298, 4397, 2941],
    'PB': [120, 185, 688],
    'PE': [120, 800, 285, 839, 1137],
    'PI': [446, 634, 1137, 1163, 1401],
    'PR': [300, 408, 991],
    'RJ': [528, 434, 429],
    'RN': [185, 537],
    'RO': [901, 544, 1456, 4397],
    'RR': [785],
    'RS': [476],
    'SC': [300, 476],
    'SE': [294, 356],
    'SP': [586, 521, 408, 1014],
    'TO': [1386, 1401, 1454, 874, 1784, 1283],
}

def get_cidade_by_uf(uf):
    """
    Retorna o nome da cidade correspondente à UF fornecida.
    """
    for cidade in MAPA:
        if cidade[2] == uf:
            return cidade[0]
    return None

def get_uf_by_cidade(cidade):
    """
    Retorna a UF correspondente à cidade fornecida.
    """
    for cidade_info in MAPA:
        if cidade_info[0] == cidade:
            return cidade_info[2]
    return None

_distancias_aereas = {
    'SE:PA': 16410.0,
    'SE:MG': 12480.0,
    'SE:RR': 30220.0,
    'SE:DF': 12920.0,
    'SE:MS': 21550.0,
    'SE:MT': 21210.0,
    'SE:PR': 20610.0,
    'SE:SC': 22070.0,
    'SE:CE': 8150.0,
    'SE:GO': 14610.0,
    'SE:PB': 4860.0,
    'SE:AP': 19670.0,
    'SE:AL': 201.0,
    'SE:AM': 2673.0,
    'SE:RN': 604.0,
    'SE:TO': 12350.0,
    'SE:RS': 2580.0,
    'SE:RO': 2946.0,
    'SE:PE': 398.0,
    'SE:AC': 3359.0,
    'SE:RJ': 1482.0,
    'SE:BA': 277.0,
    'SE:MA': 1226.0,
    'SE:SP': 1731.0,
    'SE:PI': 903.0,
    'SE:ES': 1102.0,
    'PA:MG': 21110.0,
    'PA:RR': 14320.0,
    'PA:DF': 15920.0,
    'PA:MS': 22120.0,
    'PA:MT': 17780.0,
    'PA:PR': 26650.0,
    'PA:SC': 29040.0,
    'PA:CE': 11330.0,
    'PA:GO': 16930.0,
    'PA:PB': 16360.0,
    'PA:AP': 3290.0,
    'PA:AL': 1680.0,
    'PA:AM': 1292.0,
    'PA:RN': 1550.0,
    'PA:TO': 9730.0,
    'PA:RS': 3188.0,
    'PA:RO': 1886.0,
    'PA:PE': 1676.0,
    'PA:AC': 2333.0,
    'PA:RJ': 2450.0,
    'PA:BA': 1687.0,
    'PA:MA': 481.0,
    'PA:SP': 2463.0,
    'PA:PI': 750.0,
    'PA:ES': 2275.0,
    'MG:RR': 31170.0,
    'MG:DF': 6240.0,
    'MG:MS': 11180.0,
    'MG:MT': 13720.0,
    'MG:PR': 8200.0,
    'MG:SC': 9730.0,
    'MG:CE': 18930.0,
    'MG:GO': 6660.0,
    'MG:PB': 17260.0,
    'MG:AP': 23490.0,
    'MG:AL': 1439.0,
    'MG:AM': 2556.0,
    'MG:RN': 1831.0,
    'MG:TO': 11780.0,
    'MG:RS': 1341.0,
    'MG:RO': 2477.0,
    'MG:PE': 1639.0,
    'MG:AC': 2786.0,
    'MG:RJ': 339.0,
    'MG:BA': 964.0,
    'MG:MA': 1932.0,
    'MG:SP': 489.0,
    'MG:PI': 1652.0,
    'MG:ES': 378.0,
    'RR:DF': 24960.0,
    'RR:MS': 26670.0,
    'RR:MT': 21070.0,
    'RR:PR': 33700.0,
    'RR:SC': 36200.0,
    'RR:CE': 25620.0,
    'RR:GO': 25030.0,
    'RR:PB': 30670.0,
    'RR:AP': 11100.0,
    'RR:AL': 3089.0,
    'RR:AM': 661.0,
    'RR:RN': 2983.0,
    'RR:TO': 19880.0,
    'RR:RS': 3785.0,
    'RR:RO': 1335.0,
    'RR:PE': 3103.0,
    'RR:AC': 1626.0,
    'RR:RJ': 3428.0,
    'RR:BA': 3009.0,
    'RR:MA': 1913.0,
    'RR:SP': 3300.0,
    'RR:PI': 2169.0,
    'RR:ES': 3394.0,
    'DF:MS': 8780.0,
    'DF:MT': 8730.0,
    'DF:PR': 10810.0,
    'DF:SC': 13140.0,
    'DF:CE': 16870.0,
    'DF:GO': 1730.0,
    'DF:PB': 17160.0,
    'DF:AP': 17910.0,
    'DF:AL': 1485.0,
    'DF:AM': 1932.0,
    'DF:RN': 1775.0,
    'DF:TO': 6200.0,
    'DF:RS': 1619.0,
    'DF:RO': 1900.0,
    'DF:PE': 1657.0,
    'DF:AC': 2246.0,
    'DF:RJ': 933.0,
    'DF:BA': 1060.0,
    'DF:MA': 1524.0,
    'DF:SP': 873.0,
    'DF:PI': 1313.0,
    'DF:ES': 947.0,
    'MS:MT': 5590.0,
    'MS:PR': 7800.0,
    'MS:SC': 10070.0,
    'MS:CE': 25470.0,
    'MS:GO': 7050.0,
    'MS:PB': 25930.0,
    'MS:AP': 23090.0,
    'MS:AL': 2352.0,
    'MS:AM': 2013.0,
    'MS:RN': 2654.0,
    'MS:TO': 13200.0,
    'MS:RS': 1119.0,
    'MS:RO': 1634.0,
    'MS:PE': 2530.0,
    'MS:AC': 1827.0,
    'MS:RJ': 1212.0,
    'MS:BA': 1905.0,
    'MS:MA': 2284.0,
    'MS:SP': 894.0,
    'MS:PI': 2132.0,
    'MS:ES': 1490.0,
    'MT:PR': 13020.0,
    'MT:SC': 15430.0,
    'MT:CE': 23290.0,
    'MT:GO': 7400.0,
    'MT:PB': 24950.0,
    'MT:AP': 18220.0,
    'MT:AL': 2302.0,
    'MT:AM': 1453.0,
    'MT:RN': 2524.0,
    'MT:TO': 10290.0,
    'MT:RS': 1679.0,
    'MT:RO': 1137.0,
    'MT:PE': 2452.0,
    'MT:AC': 1414.0,
    'MT:RJ': 1575.0,
    'MT:BA': 1915.0,
    'MT:MA': 1942.0,
    'MT:SP': 1326.0,
    'MT:PI': 1862.0,
    'MT:ES': 1745.0,
    'PR:SC': 2510.0,
    'PR:CE': 26700.0,
    'PR:GO': 9720.0,
    'PR:PB': 25450.0,
    'PR:AP': 28360.0,
    'PR:AL': 2259.0,
    'PR:AM': 2734.0,
    'PR:RN': 2645.0,
    'PR:TO': 16930.0,
    'PR:RS': 546.0,
    'PR:RO': 2412.0,
    'PR:PE': 2459.0,
    'PR:AC': 2601.0,
    'PR:RJ': 675.0,
    'PR:BA': 1784.0,
    'PR:MA': 2599.0,
    'PR:SP': 338.0,
    'PR:PI': 2362.0,
    'PR:ES': 1076.0,
    'SC:CE': 28570.0,
    'SC:GO': 12150.0,
    'SC:PB': 26930.0,
    'SC:AP': 30820.0,
    'SC:AL': 2402.0,
    'SC:AM': 2981.0,
    'SC:RN': 2802.0,
    'SC:TO': 19310.0,
    'SC:RS': 376.0,
    'SC:RO': 2641.0,
    'SC:PE': 2603.0,
    'SC:AC': 2809.0,
    'SC:RJ': 748.0,
    'SC:BA': 1930.0,
    'SC:MA': 2821.0,
    'SC:SP': 489.0,
    'SC:PI': 2573.0,
    'SC:ES': 1160.0,
    'CE:GO': 18540.0,
    'CE:PB': 5550.0,
    'CE:AP': 14510.0,
    'CE:AL': 730.0,
    'CE:AM': 2383.0,
    'CE:RN': 435.0,
    'CE:TO': 13000.0,
    'CE:RS': 3213.0,
    'CE:RO': 2855.0,
    'CE:PE': 629.0,
    'CE:AC': 3300.0,
    'CE:RJ': 2190.0,
    'CE:BA': 1028.0,
    'CE:MA': 652.0,
    'CE:SP': 2368.0,
    'CE:PI': 495.0,
    'CE:ES': 1855.0,
    'GO:PB': 18890.0,
    'GO:AP': 18680.0,
    'GO:AL': 1656.0,
    'GO:AM': 1912.0,
    'GO:RN': 1948.0,
    'GO:TO': 7240.0,
    'GO:RS': 1497.0,
    'GO:RO': 1813.0,
    'GO:PE': 1829.0,
    'GO:AC': 2138.0,
    'GO:RJ': 936.0,
    'GO:BA': 1225.0,
    'GO:MA': 1662.0,
    'GO:SP': 810.0,
    'GO:PI': 1467.0,
    'GO:ES': 1022.0,
    'PB:AP': 19640.0,
    'PB:AL': 299.0,
    'PB:AM': 2819.0,
    'PB:RN': 151.0,
    'PB:TO': 15210.0,
    'PB:RS': 3066.0,
    'PB:RO': 3200.0,
    'PB:PE': 104.0,
    'PB:AC': 3632.0,
    'PB:RJ': 1968.0,
    'PB:BA': 763.0,
    'PB:MA': 1162.0,
    'PB:SP': 2216.0,
    'PB:PI': 905.0,
    'PB:ES': 1581.0,
    'AP:AL': 2009.0,
    'AP:AM': 1054.0,
    'AP:RN': 1874.0,
    'AP:TO': 11770.0,
    'AP:RS': 3341.0,
    'AP:RO': 1724.0,
    'AP:PE': 2005.0,
    'AP:AC': 2159.0,
    'AP:RJ': 2687.0,
    'AP:BA': 2000.0,
    'AP:MA': 803.0,
    'AP:SP': 2664.0,
    'AP:PI': 1079.0,
    'AP:ES': 2545.0,
    'AL:AM': 2778.0,
    'AL:RN': 434.0,
    'AL:TO': 13830.0,
    'AL:RS': 2775.0,
    'AL:RO': 3090.0,
    'AL:PE': 202.0,
    'AL:AC': 3510.0,
    'AL:RJ': 1671.0,
    'AL:BA': 475.0,
    'AL:MA': 1234.0,
    'AL:SP': 1928.0,
    'AL:PI': 929.0,
    'AL:ES': 1282.0,
    'AM:RN': 2765.0,
    'AM:TO': 15090.0,
    'AM:RS': 3132.0,
    'AM:RO': 761.0,
    'AM:PE': 2833.0,
    'AM:AC': 1149.0,
    'AM:RJ': 2849.0,
    'AM:BA': 2605.0,
    'AM:MA': 1746.0,
    'AM:SP': 2689.0,
    'AM:PI': 1921.0,
    'AM:ES': 2865.0,
    'RN:TO': 15270.0,
    'RN:RS': 3172.0,
    'RN:RO': 3179.0,
    'RN:PE': 253.0,
    'RN:AC': 3616.0,
    'RN:RJ': 2085.0,
    'RN:BA': 875.0,
    'RN:MA': 1071.0,
    'RN:SP': 2320.0,
    'RN:PI': 843.0,
    'RN:ES': 1706.0,
    'TO:RS': 2222.0,
    'TO:RO': 1711.0,
    'TO:PE': 1498.0,
    'TO:AC': 2127.0,
    'TO:RJ': 1512.0,
    'TO:BA': 1114.0,
    'TO:MA': 964.0,
    'TO:SP': 1493.0,
    'TO:PI': 835.0,
    'TO:ES': 1413.0,
    'RS:RO': 2706.0,
    'RS:PE': 2977.0,
    'RS:AC': 2814.0,
    'RS:RJ': 1123.0,
    'RS:BA': 2303.0,
    'RS:MA': 3142.0,
    'RS:SP': 852.0,
    'RS:PI': 2909.0,
    'RS:ES': 1536.0,
    'RO:PE': 3190.0,
    'RO:AC': 449.0,
    'RO:RJ': 2707.0,
    'RO:BA': 2808.0,
    'RO:MA': 2274.0,
    'RO:SP': 2463.0,
    'RO:PI': 2362.0,
    'RO:ES': 2835.0,
    'PE:AC': 3618.0,
    'PE:RJ': 1874.0,
    'PE:BA': 675.0,
    'PE:MA': 1209.0,
    'PE:SP': 2128.0,
    'PE:PI': 934.0,
    'PE:ES': 1483.0,
    'AC:RJ': 2982.0,
    'AC:BA': 3206.0,
    'AC:MA': 2726.0,
    'AC:SP': 2704.0,
    'AC:PI': 2806.0,
    'AC:ES': 3156.0,
    'RJ:BA': 1209.0,
    'RJ:MA': 2266.0,
    'RJ:SP': 357.0,
    'RJ:PI': 1979.0,
    'RJ:ES': 412.0,
    'BA:MA': 1323.0,
    'BA:SP': 1453.0,
    'BA:PI': 994.0,
    'BA:ES': 839.0,
    'MA:SP': 2348.0,
    'MA:PI': 329.0,
    'MA:ES': 2023.0,
    'SP:PI': 2091.0,
    'SP:ES': 741.0,
    'PI:ES': 1713.0,
}

AEREAS = _distancias_aereas

def get_distancia_aerea(_uf1: str, _uf2: str) -> float:
    """
    Retorna a distância aérea entre duas UFs.
    """

    uf1 = _uf1.upper()
    uf2 = _uf2.upper()

    key = f'{uf1}:{uf2}'
    if key in AEREAS:
        return AEREAS[key]
    elif f'{uf2}:{uf1}' in AEREAS:
        return AEREAS[f'{uf2}:{uf1}']
    else:
        return 0

def main():
    import pandas as pd
    df = pd.read_csv('distancias_todas.csv')

    global distancias_aereas

    distancias_aereas = dict()
    for i, origem in enumerate(df.index):
        linha = df.iloc[i]
        zero_idx = linha[linha == 0].index[0]
        start_col = df.columns.get_loc(zero_idx) + 1

        for destino in df.columns[start_col:]:
            custo = float(str(df.at[origem, destino]).replace('.', ''))

            nome_origem = df.columns[i+1]
            nome_destino = destino

            uf_origem = get_uf_by_cidade(nome_origem)
            uf_destino = get_uf_by_cidade(nome_destino)

            if uf_origem:
                nome_origem = uf_origem

            if uf_destino:
                nome_destino = uf_destino

            distancias_aereas[f'{nome_origem}:{nome_destino}'] = custo

if __name__ == '__main__':
    main()


